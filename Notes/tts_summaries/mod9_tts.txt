Module 9 – Validation, DTDs, HTML5, and XML Schema
1. Validation adds business rules on top of “well formed.” DTDs start with `<!DOCTYPE RootName [ ... ]>` and declare each element with `<!ELEMENT element-name content-model>`. Use operators just like regular expressions: `(a,b,c)` for sequence, `(a|b|c)` for choice, `?` for optional, `*` for zero-or-more, and `+` for one-or-more. Example: `<!ELEMENT instructor (name, course+, officeHours, (phone|email))>` demands at least one `<course>` and exactly one of `<phone>` or `<email>`.
2. Define attributes inside an `<!ATTLIST>` block: `<!ATTLIST course level CDATA #REQUIRED campus CDATA "Tempe">`. `#REQUIRED` means the attribute must be present, `#IMPLIED` makes it optional, and providing a quoted value sets the default. DTD data types are mostly text-based (#PCDATA, CDATA, ID, IDREF, NMTOKEN), so range checks must be done elsewhere.
3. DTDs can be embedded in the XML file or referenced externally using `<!DOCTYPE instructor SYSTEM "http://.../instructor.dtd">`. Validation runs your XML instance against the DTD grammar to ensure the structure and attributes match the declared pattern.
4. HTML5 is a practical schema example. Every page begins with `<!DOCTYPE html>`, followed by `<html><head><meta charset="UTF-8"><title>...</title></head><body>...</body></html>`. New semantic tags like `<header>`, `<section>`, `<article>`, and `<footer>` give structure. Forms now include typed inputs such as `<input type="date">`, `<input type="number">`, and `<input type="range">`. Graphics rely on `<canvas>` and `<svg>`, while media use `<audio>` and `<video>` with source attributes.
5. XML Schema (XSD) is XML-based, so schemas themselves use tags. Start with `<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">`. Declare global elements via `<xsd:element name="Title" type="xsd:string"/>` or build nested structures using `<xsd:complexType>` and `<xsd:sequence>`. Control multiplicity using `minOccurs` and `maxOccurs`, e.g., `<xsd:element name="Author" minOccurs="1" maxOccurs="unbounded"/>`.
6. XSD supports rich types and namespaces. Use `targetNamespace` to announce which namespace this schema defines, and set `elementFormDefault="qualified"` if instance documents should prefix every element. Combine schemas by importing other namespaces or reusing types. Options like `<xsd:choice>` and `<xsd:all>` let you express “one-of” or “any-order” requirements, making schemas far more expressive than DTDs.
