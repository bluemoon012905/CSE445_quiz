Module 13 – Dependability, Security, and Cryptography
1. Dependability covers reliability, availability, security, safety, and integrity. Reliability `R(t)` is the probability the system works for the entire interval `[0,t]`, while availability `A(t)` is the probability it works at a specific instant `t`. If failures follow a constant rate `λ`, then `R(t) = e^{-λt}` and `MTTF = 1/λ`. When repairs happen at rate `μ`, steady-state availability is `A = μ/(λ+μ)`.
2. Attacks are different from accidental faults. Vulnerability is a weakness, confidentiality keeps data private, integrity protects correctness, and safety prevents catastrophic harm. Reliability engineering handles bugs and hardware faults, while security protects against malicious input.
3. Web threats include cross-site scripting (user input carries `<script>` tags), SQL injection (input forms embed `SELECT` or `DELETE`), hidden-field tampering, one-click attacks, DoS floods, eavesdropping, and session hijacking. Always validate inputs on the server, encode output, use HTTPS, randomize session IDs, and throttle traffic.
4. Authentication asks “who are you?” with passwords, certificates, or tokens. Authorization asks “what can you do?” with roles or ACLs. Auditing records what happened.
5. Secret-key cryptography (symmetric) uses the same key for encryption and decryption. DES, for example, works on 64-bit blocks using a 56-bit functional key and multiple Feistel rounds. Because both sides need the same key, you must protect key distribution.
6. Public-key cryptography (asymmetric) uses two keys. RSA multiplies large primes to produce a modulus; the public key encrypts, and the private key decrypts. Systems often hybridize: use RSA to exchange a secret key, then switch to faster symmetric ciphers for the session.
